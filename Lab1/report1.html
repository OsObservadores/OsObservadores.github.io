<h1 id="relat-rio-laborat-rio-1">Relatório Laboratório 1 - Captura de Imagem e Vídeo</h1>
<p>Jorge Luiz Pinto Junior  - RA: 11058715 - CEO</p>
<p>Marcos Baldrigue Andrade - RA: 11201921777 - CFO - Financeiro</p>
<p>Guilherme Eduardo Pereira - RA: 11201720498 - CPO - Desenvolvimento</p>
<p>Data de realização do experimento: 16/06/2025</p>
<p>Data de publicação do relatório: 25/06/2025</p>
<h2 id="introdu-o">Introdução</h2>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
    O presente relatório tem como objetivo descrever e analisar as atividades desenvolvidas durante o Laboratório 1 da disciplina de Visão Computacional, cujo foco principal é a familiarização com técnicas básicas de captura, exibição e gravação de imagens e vídeos utilizando a biblioteca OpenCV em Python. O Python é uma linguagem de programação de alto nível, interpretada, criada por Guido van Rossum e lançada oficialmente em 1991. É amplamente utilizada por sua simplicidade sintática e grande quantidade de bibliotecas, o que a torna ideal para aplicações nas áreas de ciência de dados, automação, inteligência artificial e visão computacional.
    Nesse contexto, destaca-se a biblioteca OpenCV (Open Source Computer Vision Library), um dos principais frameworks para o desenvolvimento de aplicações de visão computacional. A OpenCV foi criada pela Intel em 1999, com o objetivo inicial de acelerar a aplicação da visão computacional em tempo real. Desde então, tornou-se uma biblioteca open-source, mantida por uma comunidade ativa e utilizada amplamente em projetos acadêmicos e industriais. A versão para Python permite o uso de funções otimizadas para leitura, escrita, modificação e análise de imagens e vídeos, sendo uma ferramenta poderosa e acessível para iniciantes e profissionais da área.
</p>
<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
    Ao longo das atividades propostas, os alunos aplicaram comandos fundamentais para manipulação de arquivos de imagem e vídeo, explorando o funcionamento de programas específicos voltados à leitura de imagens estáticas, vídeos previamente gravados e transmissão em tempo real por meio da webcam. Além da execução e modificação dos programas fornecidos, também foram realizados experimentos práticos de captura de fotos e vídeos, visando compreender o comportamento do processamento de imagem em diferentes condições de movimento e iluminação. O relatório apresenta detalhadamente os procedimentos experimentais, as modificações realizadas nos códigos, as soluções encontradas e os arquivos gerados pela equipe, servindo como material didático completo e reprodutível para outros estudantes da disciplina.
</p>

<h2 id="procedimentos-experimentais">Procedimentos Experimentais</h2>
<h3 id="-a-leitura-de-imagem-em-arquivo">(A) Leitura de imagem em arquivo</h3>
<pre><code>import numpy as <span class="hljs-built_in">np</span>
import cv2 as <span class="hljs-built_in">cv</span>

img = <span class="hljs-built_in">cv</span>.imread('messi5.jpg',<span class="hljs-number">0</span>)
<span class="hljs-built_in">cv</span>.imshow('<span class="hljs-built_in">image</span>',img)
k = <span class="hljs-built_in">cv</span>.waitKey(<span class="hljs-number">0</span>)
<span class="hljs-keyword">if</span> k == <span class="hljs-number">27</span>:         # wait <span class="hljs-keyword">for</span> ESC <span class="hljs-built_in">key</span> to exit
    <span class="hljs-built_in">cv</span>.destroyAllWindows()
elif k == ord('s'): # wait <span class="hljs-keyword">for</span> 's' <span class="hljs-built_in">key</span> to <span class="hljs-built_in">save</span> <span class="hljs-keyword">and</span> exit
    <span class="hljs-built_in">cv</span>.imwrite('messigray.png',img)
    <span class="hljs-built_in">cv</span>.destroyAllWindows()</code></pre>


<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  O código acima realiza a leitura de uma imagem gravada em um arquivo e a mostra em uma janela do linux. Além disso, o programa permite salvar a imagem em arquivo .png pressionando uma tecla do teclado. Executamos o código e obtivemos o seguinte resultado:
</p>

<figure style="text-align: center;">
  <img src="L1_1_img.jpg" alt="Figura 1 - Resultado código L1_1" width="600" height="400">
  <figcaption>Figura 1 - Resultado código L1_1.</figcaption>
</figure>

<h3 id="-b-leitura-de-v-deo-em-arquivo">(B) Leitura de vídeo em arquivo</h3>
<pre><code><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np # Importa a biblioteca NumPy, usada para trabalhar com arrays e operações numéricas
<span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv

cap = cv.VideoCapture(<span class="hljs-string">'big_buck_bunny.mp4'</span>)

<span class="hljs-keyword">while</span>(cap.isOpened()):
    ret, frame = cap.read()

    <span class="hljs-keyword">if</span> ret==<span class="hljs-keyword">True</span>:
        <span class="hljs-comment"># show the frame</span>
        cv.imshow(<span class="hljs-string">'frame'</span>,frame)

        <span class="hljs-comment">#wait next frame by 40ms - 25fps</span>
        time.sleep(<span class="hljs-number">1</span>/<span class="hljs-number">25.0</span>) 

        <span class="hljs-keyword">if</span> cv.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == ord(<span class="hljs-string">'q'</span>):
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">break</span>

cap.release()
cv.destroyAllWindows()
</code></pre>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  O código acima realiza a leitura de um vídeo gravado em um arquivo e o exibe em uma janela do linux. O vídeo exibido é mostrado a seguir:
</p>

<video width="640" height="360" controls autoplay loop muted>
  <source src="big_buck_bunny.mp4" type="video/mp4">
</video>

<h3 id="-c-leitura-de-imagem-de-c-mera">(C) Leitura de imagem de câmera</h3>
<pre><code>import numpy <span class="hljs-keyword">as</span> np
import cv2 <span class="hljs-keyword">as</span> cv

<span class="hljs-keyword">cap</span> = cv.VideoCapture(0)

<span class="hljs-keyword">if</span> not <span class="hljs-keyword">cap</span>.isOpened():
    <span class="hljs-keyword">print</span>(<span class="hljs-string">"Cannot open camera"</span>)
    <span class="hljs-keyword">exit</span>()

<span class="hljs-keyword">while</span> True:
    # <span class="hljs-keyword">Capture</span> frame-<span class="hljs-keyword">by</span>-frame
    <span class="hljs-keyword">ret</span>, frame = <span class="hljs-keyword">cap</span>.<span class="hljs-keyword">read</span>()
    # <span class="hljs-keyword">if</span> frame is <span class="hljs-keyword">read</span> correctly <span class="hljs-keyword">ret</span> is True
    <span class="hljs-keyword">if</span> not <span class="hljs-keyword">ret</span>:
        <span class="hljs-keyword">print</span>(<span class="hljs-string">"Can't receive frame (stream end?). Exiting ..."</span>)
        <span class="hljs-keyword">break</span>

    # <span class="hljs-keyword">Display</span> the resulting frame
    cv.imshow('frame', frame)

    <span class="hljs-keyword">if</span> cv.waitKey(1) == ord('q'):
        <span class="hljs-keyword">break</span>

# When everything done, release the <span class="hljs-keyword">capture</span>
<span class="hljs-keyword">cap</span>.release()
cv.destroyAllWindows()
</code></pre>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  O código acima realiza a leitura de imagens de uma câmera instalada no computador (webcam) e exibe a sequência das imagens amostradas em uma janela do linux. Ao rodar o programa obtivemos o seguinte resultado:
</p>

<figure style="text-align: center;">
  <img src="foto1.png" alt="Figura 4 - Captura webcam." width="600" height="400">
  <figcaption>Figura 4 - Captura webcam.</figcaption>
</figure>

<h3 id="-d-grava-o-de-v-deo-da-c-mera">(D) Gravação de vídeo da câmera</h3>
<pre><code>import numpy as <span class="hljs-built_in">np</span>
import cv2 as <span class="hljs-built_in">cv</span>
cap = <span class="hljs-built_in">cv</span>.VideoCapture(<span class="hljs-number">0</span>)

# Get current <span class="hljs-built_in">width</span> of frame
<span class="hljs-built_in">width</span> = cap.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">cv</span>.CAP_PROP_FRAME_WIDTH)   # <span class="hljs-built_in">float</span>
# Get current <span class="hljs-built_in">height</span> of frame
<span class="hljs-built_in">height</span> = cap.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">cv</span>.CAP_PROP_FRAME_HEIGHT) # <span class="hljs-built_in">float</span>
# Define Video Frame Rate <span class="hljs-keyword">in</span> fps
fps = <span class="hljs-number">10.0</span>

# Define the codec <span class="hljs-keyword">and</span> create VideoWriter object
fourcc = <span class="hljs-built_in">cv</span>.VideoWriter_fourcc(*'XVID')
out = <span class="hljs-built_in">cv</span>.VideoWriter('saida.avi', fourcc, fps, (int(<span class="hljs-built_in">width</span>),int(<span class="hljs-built_in">height</span>)) )

<span class="hljs-keyword">while</span> cap.isOpened():
    ret, frame = cap.<span class="hljs-built_in">read</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Can't receive frame (stream end?). Exiting ..."</span>)
        <span class="hljs-built_in">break</span>
    frame = <span class="hljs-built_in">cv</span>.flip(frame, <span class="hljs-number">0</span>)
    # write the flipped frame
    out.write(frame)
    <span class="hljs-built_in">cv</span>.imshow('frame', frame)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">cv</span>.waitKey(<span class="hljs-number">1</span>) == ord('q'):
        <span class="hljs-built_in">break</span>

# Release everything <span class="hljs-keyword">if</span> job <span class="hljs-built_in">is</span> finished
cap.release()
out.release()
<span class="hljs-built_in">cv</span>.destroyAllWindows()
</code></pre>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  O script acima realiza a leitura de imagens da câmera e exibe a sequência de imagens numa janela do linux. Ao digitar a tecla 'q' salva toda a sequência de imagens num arquivo "saida.avi" no formato AVI de vídeo. O resultado da execução do script é mostrado a seguir:
</p>

<video width="640" height="360" controls>
  <source src="video_objeto_rapido.avi" type="video/avi">
  <source src="video_objeto_rapido.avi" type="video/x-msvideo">
</video>

<h2 id="an-lise-e-discuss-o">Análises e discussões</h2>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  A seguir, são descritas as modificações e testes solicitados em cada um dos quatro códigos.
</p>

<h3 id="-a-leitura-de-imagem-em-arquivo">(A) Leitura de imagem em arquivo</h3>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  Mediante os resultados, foi proposta a seguinte pergunta: <strong>Por que a janela não mostra a imagem colorida?</strong>
  A imagem foi exibida em preto e branco devido ao parâmetro "imreadModes" que está setado com valor zero. Como mostra a imagem abaixo, podemos setar este parâmetro para diferentes resultados desejados:
</p>

<figure style="text-align: center;">
  <img src="L1_1_img_pq_preto_e_branco.jpg" alt="Figura 2 - Parâmetro imreadModes" width="400" height="450">
  <figcaption>Figura 2 - Parâmetro imreadModes.</figcaption>
</figure>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  A seguir modificamos o parâmetro "imreadModes" para 256 e obtivemos o seguinte resultado:
</p>

<figure style="text-align: center;">
  <img src="imreadModes_256.jpg" alt="Figura 3 - imreadModes = 256." width="400" height="500">
  <figcaption>Figura 3 - imreadModes = 256.</figcaption>
</figure>

<h3 id="-b-leitura-de-v-deo-em-arquivo">(B) Leitura de vídeo em arquivo</h3>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  As seguintes alterações foram prospostas: Modifique o programa para que as imagens sejam exibidas <strong>mais rápidamente</strong> e depois para que seja exibidas <strong>mais lentamente</strong>. Responda: Qual a explicação de alteração de velocidade de exibição e apresente suas conclusões detalhadamente:
</p>
<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  Verificamos que o comando que controla a velocidade de exibição é o comando: <strong>time.sleep(1/25.0)</strong>. Este comando divide 1 segundo de vídeo por 25 quadros (FPS), então um novo frame é exibido a cada 40 milisegundos.
</p>
<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  Então para alterarmos a velocidade de exibição basta alteramos o valor de FPS. O vídeo a seguir executa o comando com a seguinte configuração <strong>time.sleep(1/60)</strong>, ou seja, em 60 quadros por segundo, portanto um novo frame é exibido a cada 1 milisegundo.
</p>

<pre><code><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv

cap = cv.VideoCapture(<span class="hljs-string">'big_buck_bunny.mp4'</span>)

<span class="hljs-keyword">while</span>(cap.isOpened()):
    ret, frame = cap.read()

    <span class="hljs-keyword">if</span> ret==<span class="hljs-keyword">True</span>:
        <span class="hljs-comment"># show the frame</span>
        cv.imshow(<span class="hljs-string">'frame'</span>,frame)

        <span class="hljs-comment">#wait next frame by 1ms - 60fps</span>
        time.sleep(<span class="hljs-number">1</span>/<span class="hljs-number">60.0</span>) 

        <span class="hljs-keyword">if</span> cv.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == ord(<span class="hljs-string">'q'</span>):
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">break</span>

cap.release()
cv.destroyAllWindows()
</code></pre>

<video id='meuVideo' width="640" height="360" controls autoplay loop muted>
  <source src="big_buck_bunny.mp4" type="video/mp4">
</video>

<script>
    // Define a velocidade de reprodução (por exemplo, 2.0x)
    document.getElementById('meuVideo').playbackRate = 2.0;
</script>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  A seguir, alteramos o comando da seguinte forma: <strong>time.sleep(1/120)</strong>, ou seja, 120 quadros por segundo, portanto, um novo quadro é exibido a cada 0,5 milisegundos.
</p>

<pre><code><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv

cap = cv.VideoCapture(<span class="hljs-string">'big_buck_bunny.mp4'</span>)

<span class="hljs-keyword">while</span>(cap.isOpened()):
    ret, frame = cap.read()

    <span class="hljs-keyword">if</span> ret==<span class="hljs-keyword">True</span>:
        <span class="hljs-comment"># show the frame</span>
        cv.imshow(<span class="hljs-string">'frame'</span>,frame)

        <span class="hljs-comment">#wait next frame by 0.5ms - 120fps</span>
        time.sleep(<span class="hljs-number">1</span>/<span class="hljs-number">120.0</span>) 

        <span class="hljs-keyword">if</span> cv.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == ord(<span class="hljs-string">'q'</span>):
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">break</span>

cap.release()
cv.destroyAllWindows()
</code></pre>

<video id='meuVideo2' width="640" height="360" controls autoplay loop muted>
  <source src="big_buck_bunny.mp4" type="video/mp4">
</video>

<script>
    // Define a velocidade de reprodução (por exemplo, 2.0x)
    document.getElementById('meuVideo2').playbackRate = 4.0;
</script>
<h3 id="-c-leitura-de-imagem-de-c-mera">(C) Leitura de imagem de câmera</h3>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  Foi proposto que se alterasse o código fornecido para que uma imagem da câmera fosse salva ao pressionar a tecla <strong>"x"</strong> do teclado. A seguir, o detalhamento das ações tomadas: 
</p>

<figure style="text-align: center;">
  <img src="captura_tecla_x.jpg" alt="Figura 5 - Ajuste do script para captura." width="450" height="550">
  <figcaption>Figura 5 - Ajuste do script para captura de imagem com tecla x.</figcaption>
</figure>

<p style="text-align: justify; line-height: 1.5; text-indent: 2em;">
  O ajuste realizado foi inserir a condição destacada na imagem, ou seja, o comando <strong>cv.waitKey(1) == ord('x')</strong> serve para verificar se foi pressionada a tecla x em algum momento e se esta condição for verdadeira o seguinte comando é executado: <strong>cv.imwrite('foto1.png',frame)</strong>. Este comando salva em um arquivo de imagem o frame no momento em que a tecla foi pressionada. Como o terminal foi executado na pasta do laboratório 1, não foi preciso indicar um diretório de saída pois a imagem é salva onde o programa foi executado.
</p>

<figure style="text-align: center;">
  <img src="diretorio_foto_1.jpg" alt="Figura 6 - Diretório foto 1." width="500" height="350">
  <figcaption>Figura 6 - Diretório do arquivo foto1.png.</figcaption>
</figure>


<h3 id="-d-grava-o-de-v-deo-da-c-mera">(D) Gravação de vídeo da câmera</h3>

<h2 id="conclus-o">Conclusão</h2>

<h2 id="Ref-s">Referências</h2>
